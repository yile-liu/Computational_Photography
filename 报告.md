# Image Completion with Structure Propagation

## 成员

| 姓名   | 学号       |
| ------ | ---------- |
| 苏厚先 | 3200102706 |
| 刘思锐 | 3200102708 |

## 项目内容

用户在界面中画出待补全的区域以及结构线，本算法在已知图像区域采样，选取最匹配图像块将空洞区域补全。

![image-20230615133715620](./报告.assets/image-20230615133715620.png)

### 用户界面

项目启动方法为：

`$ /path/to/ImageCompletion  ./source_file ./save_path`

工程实现了两个图形化用户界面：

### 结构补全

传统计算机程序无法推测图片缺失区域的物体轮廓，比如在这个例子中：

因此图像补全的第一步是用户手动画出结构线指示图像内物体的边缘；算法在结构线上的已知区域内采样，填补结构线上的未知区域，以此补全物体的结构轮廓。

### 纹理补全

经过结构补全，缺失的块中应该不含有结构轮廓信息，此时算法会在

### 光测度一致性矫正

光测度一致性矫正使用与泊松图像编辑相似的原理。

## 理论分析

### 结构补全

结构补全要求“对结构线上每一个未知的块，在结构线上已知的部分中挑选一个最合适的块填充到此处”，显然是一个优化问题。

#### 优化函数

我们定义优化函数如下：

<img src="./报告.assets/image-20230615143556957.png" alt="image-20230615143556957" style="zoom:33%;" />

<img src="./报告.assets/image-20230615143617498.png" alt="image-20230615143617498" style="zoom:33%;" />

其中$E_S$衡量结构线方向的相似程度。将待填补的方块$c_i$与当前选取的已知方块$c_{xi}$重叠，将两者的结构线逐像素采样，计算到另一条结构线的最短距离，并将结果加和。此项的值越小说明所选的块与待填补的块结构越相近。

<img src="./报告.assets/image-20230615143629887.png" alt="image-20230615143629887" style="zoom:33%;" />

<img src="./报告.assets/image-20230615143906586.png" alt="image-20230615143906586" style="zoom:33%;" />

$E_I$衡量新填补的块与已知区域的相似程度。如果填补的方块与已知区域有重叠（如下图中绿色所示），则将重合区域逐像素采样，计算所选的块与已知边缘灰度的标准化平方差（SSD）。此项的值越小说明所选的块与已知边缘越相近，补全效果越自然。与已知区域没有重叠的未知区域，此项的值为 0。

<img src="./报告.assets/image-20230615144306166.png" alt="image-20230615144306166" style="zoom:33%;" />

$E_2$衡量前后两个填补块之间的相似程度。如果两个先后填补的块之间有重叠（如上图中红色所示），则将两者的重合部分逐像素采样，计算两者灰度的 SSD。此项的值越小说明当前填补的块与前一个块的纹理越相近，结构线越平滑。

#### 优化算法

当结构线间没有交叉时，因为$E_2$的计算只与此前一个补全的块有关，我们很容易用一个一维的动态规划（BP）得到结构线上每个点的最优解：

<img src="./报告.assets/image-20230615145636902.png" alt="image-20230615145636902" style="zoom:33%;" />

但是当结构线之间有交叉，形成十字形的结构时，一方面，不同的补全顺序将影响到交叉处的$E_2$计算；另一方面，通过 DP 遍历十字形结构线四个方向上的已知信息找出最优解的计算量非常大（指数级，在参考论文[1]中给出了证明）。因此当结构线存在交叉时，我们使用信念传播（BP）的方法进行计算。

<img src="./报告.assets/image-20230615152104959.png" alt="image-20230615152104959" style="zoom:33%;" />

信念传播是一种本地消息传递算法，它可以最小化任何无向成对图上定义的能量函数，例如我们的 E(X)。信念传播的基本机制是图中的每个节点接收来自其邻居的消息，然后将更新的消息发送回每个邻居。我们将从节点 i 到 j 发送的消息表示为 Mij，它是一个具有 N 个元素的向量。Mij 表示节点 i 相信节点 j 具有相应标签 xj 的概率。上图展示了用于图像完成的信念传播的主要过程。

信念传播有两个版本：和乘积求和（sum-product）以及最大乘积（max-product）。求和乘积计算每个节点的边缘后验概率，而最大乘积则最大化每个节点的后验概率。在本算法中，我们使用最大乘积与负对数概率，将最大乘积转化为最小和（min-sum）。

<img src="./报告.assets/image-20230615153901598.png" alt="image-20230615153901598" style="zoom:33%;" />

<img src="./报告.assets/image-20230615153915702.png" alt="image-20230615153915702" style="zoom:33%;" />

比如在上图(c)中，传播过程为：

<img src="./报告.assets/image-20230615154305382.png" alt="image-20230615154305382" style="zoom:33%;" />

其中 M 的计算如下：

<img src="./报告.assets/image-20230615154323848.png" alt="image-20230615154323848" style="zoom:33%;" />

对于一个包含循环的图形，我们仍然可以使用 BP 算法而不需要担心环形传播导致算法死循环。对于一个只有一个循环的图形，参考论文[3]已经证明如果最大乘积置信传播算法收敛，将得到最优解。对于一个包含多个循环的图形，循环置信传播通常在收敛时得到一个局部最小值。在我们的实验中，BP 算法的表现良好。

### 纹理补全

### 光测度一致性矫正

## 实现细节

### 用户界面

用户界面依赖OpenCV的HighGUI用户界面图形库实现。

#### Mask 绘制界面

Mask 绘制界面的核心是鼠标回调函数：

```c++
static void drawMaskMouseCallback
  (int event, int x, int y, int flags, void *param)
{
  static bool hold_left = false;
  if (event == EVENT_LBUTTONDOWN)
    hold_left = true;
  else if (event == EVENT_LBUTTONUP)
    hold_left = false;

  static Point pt_curr = Point(-1, -1);
  static Point pt_prev = Point(-1, -1);

  pt_prev = pt_curr.x == -1 ? Point(x, y) : pt_curr;
  pt_curr = Point(x, y);

  if (hold_left)
  {
    line(mask, pt_prev, pt_curr, Scalar(0), 2 * brush_size);
    line(image_with_mask, pt_prev, pt_curr, 
         Scalar(255, 0, 0), 2 * brush_size);
  }

  static Mat image_with_mask_and_brush;
  image_with_mask_and_brush = image_with_mask.clone();
  circle(image_with_mask_and_brush, pt_curr, 
         brush_size, Scalar(85, 85, 255), -1);

  imshow("Draw Mask", image_with_mask_and_brush);
}
```

Mask绘制同时改动了两个矩阵，其一是原图的克隆，其中用户涂画的部分设置为特殊的颜色，并显示在屏幕上作为UI提示；其二是真正的Mask遮罩矩阵，初始值为0，用户涂画的部分则设置为255，不对外显示。

出于HighGUI库的鼠标事件采样率较低的原因，如果绘制时只以当前鼠标位置为画圆，则容易在按住左键并拖动画笔时画出一串离散的点，而不是连贯的线条。因此鼠标回调函数中以静态变量的形式维护了前一次回调中鼠标的位置；每次进行绘制画出的并不是圆形，而是两端呈半圆形的线。

此处还有一个插曲是，在我们的开发环境中，标志鼠标按键状态的flags变量始终为0，因此我们不得不手动维护鼠标左键的按下状态。

#### 结构线绘制界面

结构线绘制界面的核心同样在鼠标回调函数中：

```c++
static void structurePropagationMouseCallBack
  (int event, int x, int y, int flags, void *param)
{
  // details ommitted here
  if (event == EVENT_LBUTTONDOWN)
  {
    curr_point_set.emplace_back(x, y);
  }
  else if (event == EVENT_RBUTTONDOWN)
  {
    if (line_or_curve == CURVE && curr_point_set.size() > 1)
      structure_lines.emplace_back(vector<Point>(curr_point_set));

    curr_point_set.clear();
  }

  if (line_or_curve == LINE && curr_point_set.size() == 2)
  {
    structure_lines.emplace_back(vector<Point>(curr_point_set));
    curr_point_set.clear();
  }
  // details ommitted here
}
```

绘制结构线时，直线和曲线都是若干个离散的锚点前后相接，区别仅在于绘制直线时，锚点集内有两个点即认为此条线结束，而绘制曲线时点集内可以有任意个点，仅当按下鼠标右键时结束。

在完成结构线绘制，进行结构补全之前，还需要对结构线进行一些处理。首先是根据离散的锚点，对线条逐像素采样为稠密的点集。在采样时，算法首先判断当前一对锚点所确定的线段的斜率，然后以x/y中斜率较小的一方做自变量，另一方根据斜率计算浮点数坐标值，再四舍五入到整数。

```c++
for (int i = 0; i < (int)(point_set.size()) - 1; i++)
{
  int abs_x = std::abs(point_set[i].x - point_set[i + 1].x);
  int abs_y = std::abs(point_set[i].y - point_set[i + 1].y);

  // in case a "line" begin and end at the same pixel
  if (point_set[i].x != point_set[i + 1].x && 
      point_set[i].y != point_set[i + 1].y)
  {
    vector<Point> point_samples;
    if (abs_y > abs_x){ // 以y为自变量采样
    }else{ // 以x为自变量采样
    }
    line_points.emplace_back(vector<Point>(point_samples));
  }
}
```

完成采样后，我们将稠密的点集输入PointManager中。PointManager负责对点集进行数据结构上的转换，以便后续的代码实现，提高算法运行效率。

### PointManager



### 结构补全

#### DP

#### BP

### 纹理补全

### 光测度一致性矫正

## 结果展示

## 参考文献
